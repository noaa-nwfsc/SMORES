---
title: "`r paste(params$submodel_name, 'Combined Submodel Report')`"
date: "`r format(Sys.time(), '%B %d, %Y at %H:%M:%S')`"
output: 
  html_document:
    theme:
      version: 5
      brand: _brand.yml
    toc: true
    toc_float: true
    self_contained: true
params:
  submodel_name: "Combined Submodel"
  selected_components: NULL
  component_methods: NULL
  combined_data: NULL
  combined_map_title: "Combined Submodel Map"
  data_timestamps: NULL
  aoi_data: NULL
  component_layer_details: NULL
  component_data_summary: NULL
  aoi_cropped_map: NULL,
  aoi_cropped_normalized_map: NULL
---

```{css, include = FALSE}
<style>
body {
max-width: 1200px;
margin: 0 auto;
padding: 20px;
font-family: 'Arial', sans-serif;
}

.main-container {
max-width: 1200px;
margin: 0 auto;
}

h1, h2, h3, h4, h5, h6 {
text-align: center;
margin: 20px 0;
}

.leaflet-container {
margin: 20px auto;
display: block;
}

table {
margin: 20px auto;
max-width: 800px;
}

.table {
margin: 20px auto;
}

p {
text-align: justify;
margin: 15px 0;
}

.tocify-wrapper {
position: fixed;
top: 0;
left: 0;
width: 260px;
height: 100%;
overflow: auto;
z-index: 1000;
}

.col-md-9 {
margin-left: 280px;
max-width: calc(100% - 300px);
}

/* Center specific elements */
.centered-content {
text-align: center;
margin: 20px auto;
}

/* Map container centering */
.map-container {
display: flex;
justify-content: center;
margin: 20px 0;
}

/* Ensure leaflet maps are responsive and centered */
.leaflet {
max-width: 100%;
height: 400px;
margin: 0 auto;
}

/* Style for configuration table */
.config-table {
margin: 20px auto;
max-width: 800px;
}

/* Center all chunk outputs */
.chunk-output {
text-align: center;
}

/* Center kable tables */
.kable-table {
margin-left: auto;
margin-right: auto;
}

/* Component summary styling */
.component-summary {
background-color: #f8f9fa;
border: 1px solid #dee2e6;
border-radius: 8px;
padding: 15px;
margin: 15px 0;
}

.component-header {
background-color: #e9ecef;
border-radius: 5px;
padding: 10px;
margin-bottom: 10px;
font-weight: bold;
}
</style>
```

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE, fig.width = 12, fig.height = 8)

# Load required libraries
suppressPackageStartupMessages({
  library(leaflet)
  library(sf)
  library(dplyr)
  library(knitr)
  library(htmltools)
})

# Null coalescing operator
`%||%` <- function(x, y) if(is.null(x)) y else x

# Function to create combined submodel map
create_combined_submodel_map <- function(combined_data, title, wea_data = NULL) {
  if (is.null(combined_data)) {
    return(leaflet() %>%
             addProviderTiles("Esri.OceanBasemap") %>%
             addControl("No combined submodel data available.", position = "topright"))
  }
  
  # Determine the value column - should be "Geo_mean" for combined submodel
  value_column <- if("Geo_mean" %in% names(combined_data)) "Geo_mean" else "Combined_Score"
  
  if (!value_column %in% names(combined_data)) {
    return(leaflet() %>%
             addProviderTiles("Esri.OceanBasemap") %>%
             addControl("No valid combined score data available.", position = "topright"))
  }
  
  # Ensure data is in the correct CRS for leaflet
  if (inherits(combined_data, 'sf') && !identical(st_crs(combined_data)$input, '+proj=longlat +datum=WGS84')) {
    combined_data <- st_transform(combined_data, '+proj=longlat +datum=WGS84')
  }
  
  # Filter out NA values for domain calculation
  valid_values <- combined_data[[value_column]][!is.na(combined_data[[value_column]])]
  
  if(length(valid_values) == 0) {
    return(leaflet() %>%
             addProviderTiles("Esri.OceanBasemap") %>%
             addControl("No valid data available for combined submodel.", position = "topright"))
  }
  
  # Create color palette
  pal <- colorNumeric(
    palette = "viridis",
    domain = range(valid_values),
    na.color = 'transparent'
  )
  
  # Create popup text
  popup_text <- ~paste0(
    '<strong>Combined Score:</strong> ', round(get(value_column), 3), '<br>',
    '<strong>Cell ID:</strong> ', CellID_2km
  )
  
  # Create the base map
  map <- leaflet(combined_data) %>%
    addProviderTiles("Esri.OceanBasemap",
                     options = providerTileOptions(variant = "Ocean/World_Ocean_Base")) %>%
    addProviderTiles("Esri.OceanBasemap",
                     options = providerTileOptions(variant = "Ocean/World_Ocean_Reference")) %>%
    addPolygons(
      fillColor = ~pal(get(value_column)),
      weight = 1,
      opacity = 1,
      color = '#00000000',
      fillOpacity = 0.7,
      popup = popup_text,
      group = "Combined Data"
    ) %>%
    addLegend(
      pal = pal,
      values = ~get(value_column),
      title = title,
      position = 'bottomright',
      opacity = 1
    )
  
  # Add WEA boundary if available
  if (!is.null(wea_data) && nrow(wea_data) > 0) {
    # Transform WEA data if needed
    if (!st_is_longlat(wea_data)) {
      wea_data <- st_transform(wea_data, 4326)
    }
    wea_data <- st_zm(wea_data)
    
    map <- map %>%
      addPolygons(
        data = wea_data,
        fillColor = "transparent",
        color = "red",
        weight = 3,
        fillOpacity = 0,
        popup = ~paste("WEA Area:", Area_Name),
        group = "WEA Boundary"
      ) %>%
      addLayersControl(
        overlayGroups = c("Combined Data", "WEA Boundary"),
        options = layersControlOptions(collapsed = FALSE)
      )
  }
  
  return(map)
}
```

```{r}
# Add detailed component layer information
if (!is.null(params$component_layer_details) && length(params$component_layer_details) > 0) {
  cat("## Individual Layers Used in Combined Submodel\n\n")
  
  # Create a comprehensive table showing all layers used in each component
  layer_details_list <- list()
  
  for (component in names(params$component_layer_details)) {
    component_data <- params$component_layer_details[[component]]
    component_method <- component_data$method %||% "Unknown"
    component_layers <- component_data$layers %||% list()
    
    
    if (length(component_layers) > 0) {
      for (i in seq_along(component_layers)) {
        # Safely extract values with fallbacks
        layer_name <- component_layers[[i]]$layer_name %||% "Unknown"
        score_used <- component_layers[[i]]$score_used %||% "Unknown"
        
        layer_details_list[[length(layer_details_list) + 1]] <- data.frame(
          Component = component,
          Method = component_method,
          Layer_Name = layer_name,
          Score_Used = score_used,
          stringsAsFactors = FALSE
        )
      }
    }
  }
  
  if (length(layer_details_list) > 0) {
    # Combine all layer details into one data frame
    all_layer_details <- do.call(rbind, layer_details_list)
    
    kable(all_layer_details, 
          col.names = c("Component", " Component Calculation Method", "Layer Name", "Score Used"),
          caption = "Individual Layers and Scores Used in Each Component",
          format = "html",
          table.attr = "class='table table-striped config-table'")
  } else {
    cat("No individual layer details available.\n")
  }
} else {
  cat("Individual layer information not available.\n")
}
```

The combined submodel map represents the integration of all selected components using their specified calculation methods. The final combination is calculated using the geometric mean of the component scores to produce a unified assessment.

```{r}
if (!is.null(params$combined_data)) {
  # Check if combined_data has the geometry and expected columns
  if (inherits(params$combined_data, 'sf')) {
    cat("**Combined Submodel Data Points:** ", nrow(params$combined_data), "  \n")
    cat("**Final Combination Method:** Geometric Mean of Component Scores  \n")
    
    # Show value column information
    value_column <- if("Geo_mean" %in% names(params$combined_data)) "Geo_mean" else "Combined_Score"
    if (value_column %in% names(params$combined_data)) {
      valid_values <- params$combined_data[[value_column]][!is.na(params$combined_data[[value_column]])]
      if(length(valid_values) > 0) {
        cat("**Value Range:** ", round(min(valid_values), 3), " to ", round(max(valid_values), 3), "  \n")
      }
    }
    cat("\n")
  }
} else {
  cat("*Combined submodel data not available.*\n\n")
}

if (!is.null(params$combined_data)) {
  create_combined_submodel_map(params$combined_data, params$combined_map_title %||% "Combined Submodel",
                               aoi_data = params$aoi_data)
} else {
  # Show placeholder message
  cat("*Combined submodel was not generated.*\n")
}
```

The AOI-cropped map shows the same combined submodel data filtered to the selected Area of Interest (AOI), maintaining the original color scale for consistency with the full dataset.

```{r}
if (!is.null(params$aoi_cropped_map)) {
  params$aoi_cropped_map
} else {
  cat("*AOI-cropped map not available. Please select a specific AOI area.*\n")
}
```

The normalized AOI-cropped map shows the AOI-filtered data rescaled to a 0-1 range using a min max normalization for only the values within the selected area, making it easier to compare relative differences within the AOI.

```{r}
if (!is.null(params$aoi_cropped_normalized_map)) {
  params$aoi_cropped_normalized_map
} else {
  cat("*AOI-cropped normalized map not available. Please select a specific AOI area.*\n")
}
```